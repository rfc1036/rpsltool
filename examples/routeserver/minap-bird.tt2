[%
# vim: syntax=tt2 shiftwidth=2 autoindent
USE date;
USE wrap;

# determine the "short" alphanumeric name of each neighbor
FOREACH ip = conf.keys;
  IF conf.$ip.name;
    conf.$ip.name = conf.$ip.name | lower;
  ELSIF conf.$ip.description;
    conf.$ip.name = conf.$ip.description.replace('[^a-zA-Z0-9]+', '') | lower;
  ELSE;
    conf.$ip.name = 'as' _ conf.$ip.as;
  END;
END;

# Remove the IPv4 or the IPv6 peers depending on the "ipv6" configuration
# variable in the template, because BIRD needs one config file for each AFI.
FOREACH ip = conf.keys;
  neigh = conf.$ip;
  IF    var.ipv6 == 'y' AND NOT ip.match(':');
    conf.delete(ip);
  ELSIF var.ipv6 == 'n' AND     ip.match(':');
    conf.delete(ip);
  END;
END;

%]
/*****************************************************************************
*
* BIRD configuration for rs1.minap.it
* Generated on [% date.format(date.now, '%F %T') %].
*
*****************************************************************************/
/* http://bird.network.cz/?get_doc&f=bird-3.html */

timeformat base         iso long;
timeformat log          iso long;
timeformat protocol     iso long;
timeformat route        iso long;

router id 185.1.114.252;
[% IF var.ipv6 == 'y' %]
listen bgp address 2001:7f8:c5::1;
[% ELSE %]
listen bgp address 185.1.114.252;
[% END %]

#debug protocols { states, routes, filters };
debug protocols { states };

# must be configured, even empty, or BGP will be silently disabled
protocol device { }

/****************************************************************************/
/* http://bird.network.cz/?get_doc&f=bird-5.html */

function invalid_prefix()
prefix set invalid;
{
	invalid = [
[% IF var.ipv6 == 'y' %]
		3ffe::/16+, 2001:db8::/32+,
		fe00::/9+, ff00::/8+, ::/128-,
		::0/0{0,15}, ::/0{49,128}
[% ELSE %]
		10.0.0.0/8+, 192.168.0.0/16+, 172.16.0.0/12+,
		127.0.0.0/8+, 169.254.0.0/16+, 224.0.0.0/4+, 240.0.0.0/4+,
		0.0.0.0/32-, 0.0.0.0/0{0,7}, 0.0.0.0/0{25,32}
[% END %]
	];
	if net ~ invalid then return true;
	return false;
}

# http://bgpfilterguide.nlnog.net/guides/bogon_asns/
function reject_bogon_asns()
int set bogon_asns;
{
	bogon_asns = [
		0,		# RFC 7607
		23456,		# RFC 4893 AS_TRANS
		64496..64511,	# RFC 5398 and documentation/example ASNs
		64512..65534,	# RFC 6996 Private ASNs
		65535,		# RFC 7300 Last 16 bit ASN
		65536..65551,	# RFC 5398 and documentation/example ASNs
		65552..131071,	# RFC IANA reserved ASNs
		4200000000..4294967294, # RFC 6996 Private ASNs
		4294967295	# RFC 7300 Last 32 bit ASN
	];

	if (bgp_path ~ bogon_asns) then {
		print "REJECT: bogon AS_PATH: ", net, " ", bgp_path;
		return true;
	}

	return false;
}

# http://bgpfilterguide.nlnog.net/guides/no_transit_leaks/
function transit_path(int peeras)
int set transit_free_as;
{
	transit_free_as = [
		# good for Italy
		137, 1267, 3269, 12874,
		# inspired by https://en.wikipedia.org/wiki/Tier_1_network
[% IF var.ipv6 == 'n' %]
		209, 4134, 12956,
[% END %]
		174,      286, 701, 702, 703, 1239, 1299,
		2828, 2914, 3257, 3320, 3356, 3491, 3549, 3561,
		      5511, 6453, 6461, 6762, 6830, 7018
	];

	if bgp_path.first ~ transit_free_as then return false;

	if (bgp_path ~ transit_free_as) then {
		print "REJECT: Transit ASN from ", peeras, ": ",
			net, " ", bgp_path;
		return true;
	}
	return false;
}

function bgp_in(int peeras)
{
	# enforce the presence of the peer AS as the first AS of the path
	if !(bgp_path.first = peeras) then return false;
	# basic sanity checks
	if (invalid_prefix()) then return false;
	return true;
}

function bgp_out(int peerasn)
{
	# sanity check: ignore routes not learned from BGP
	if !(source = RTS_BGP) then return false;

	# graceful shutdown well known community
	if (65535, 0) ~ bgp_community then {
		bgp_local_pref = 0;
	}

	# blackholing community
	if (65535, 666) ~ bgp_community then {
[% IF var.ipv6 == 'y' %]
		bgp_next_hop = 2001:7f8:c5::666;
[% ELSE %]
		bgp_next_hop = 185.1.114.66;
[% END %]
	}

	# Large BGP Communities
	# do not advertise to <peerasn>
	if ([% var.myasn %], 0,peerasn) ~ bgp_large_community then return false;
	# advertise to <peerasn>
	if ([% var.myasn %], 1,peerasn) ~ bgp_large_community then return true;
	# do not advertise to any peer
	if ([% var.myasn %], 0,0)       ~ bgp_large_community then return false;
	# advertise to all peers
	if ([% var.myasn %], 1,0)       ~ bgp_large_community then return true;

	# mapping of large communities to normal communities:
	# mapping base = 2^16-2^(32-23) = 65024
	# mapped community = base + last_byte(v4_address)

	case peerasn {
		# skip any large ASN not yet defined
		65536 .. 4294967295: return true;
	}

	# Normal communities
	# do not advertise to <peerasn>
	if (0,     peerasn)           ~ bgp_community  then return false;
	# advertise to <peerasn>
	if ([% var.myasn %], peerasn) ~ bgp_community  then return true;
	# do not advertise to any peer
	if (0,     [% var.myasn %])   ~ bgp_community  then return false;
[% IF var.defaultdeny %]
	# advertise to all peers
	if ([% var.myasn %], [% var.myasn %]) ~ bgp_community  then return true;
	return false;
[% ELSE %]
	return true;
[% END %]
}

/****************************************************************************/
template bgp tb_rsclient {
	local as [% var.myasn %];
	passive;

	interpret communities no;
	import filter {
		# prevent next-hop hijacking
		if !(from = bgp_next_hop) then
			reject "REJECT: BGP neighbor address ", from,
			" != next hop address ", bgp_next_hop,
			" for ", net, " path:", bgp_path;
		accept;
	};
	export all;
	rs client;
}

/****************************************************************************/
/* For the pipe protocol, export filters control export of routes from the
 * primary table ("table") to the secondary one ("peer table"), import
 * filters control the opposite direction.
 */
[% seen = [] %]
[% FOREACH ip = conf.keys.ipsort %]
[%
neigh = conf.$ip;
afi = var.ipv6 == 'y' ? 'ipv6' : 'ipv4';

# generate the configuration once even if the AS has multiple addresses
IF seen.${neigh.as};
  NEXT;
ELSE;
  seen.${neigh.as} = 1;
END;
%]
function bgp_[% neigh.name %]_in()
prefix set [% neigh.name %]_in;
int set [% neigh.name %]_as_in;
{
[% IF neigh.$afi.import_as AND neigh.$afi.import_as.size > 0 %]
	[% neigh.name %]_as_in = [
[% neigh.$afi.import_as.nsort.join(', ') | wrap +%]
	];
	if !(bgp_path.last ~ [% neigh.name %]_as_in) then return false;
[% END %]
	if (reject_bogon_asns()) then return false;
	if (transit_path([% neigh.as %])) then return false;
[% IF neigh.$afi.import_routes AND neigh.$afi.import_routes.size > 0 %]
	[% neigh.name %]_in = [
[% neigh.$afi.import_routes.ipsort.route2bird.join(', ') | lower | wrap +%]
	];
	if !(net ~ [% neigh.name %]_in) then return false;
[% END %]
	if !(bgp_in([% neigh.as %])) then return false;
	return true;
}

table T_[% neigh.name | upper %];

protocol pipe P_[% neigh.name | upper %] {
	table master;
	mode transparent;
	peer table T_[% neigh.name | upper %];
	/* routes from the global table to [% neigh.name %] */
	export where bgp_out([% neigh.as %]) = true;
	/* routes from [% neigh.name %] to the global table */
	import where bgp_[% neigh.name %]_in() = true;
}


[% END %]

/****************************************************************************/
/* http://bird.network.cz/?get_doc&f=bird-6.html */

[% seen = [] %]
[% FOREACH ip = conf.keys.ipsort %]
[%
neigh = conf.$ip;

# Use a different name when there are multiple neighbors from the same AS.
# The regexp needs to be modified if the peering network is > /24.
IF seen.${neigh.as};
  extraname = '_' _ ip.remove('^.+[\.:]');
ELSE;
  seen.${neigh.as} = 1;
  extraname = '';
END;
%]
protocol bgp [% neigh.name | upper %][% extraname %] from tb_rsclient {
[% IF neigh.description %]
	description "[% neigh.description %]";
[% END %]
	neighbor [% ip %] as [% neigh.as %];
	table T_[% neigh.name | upper %];
[% IF neigh.maxpref %]
	import limit [% neigh.maxpref %] action restart;
[% END %]
[% FOREACH cmd = neigh.bgp_commands %]
	[% cmd %];
[% END %]
}

[% END %]

/* END OF FILE MARKER */

